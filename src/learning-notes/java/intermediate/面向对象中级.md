# 面向对象中级
<!-- more -->

## 包

### 包的三大作用

- **区分相同名字的类**
- **控制访问范围**
- **当类很多时,可以很好的管理类**

### 包的基本语法

**package com.haspedu;**
1. **package** 关键字， 表示打包
2. **com.hspedu** 表示报名

### 包的本质分析（原理）

包的本质 实际上就是创建不同的文件夹来保存类文件

### 演示
```java
// 第一个包文件 包名称为 com.xiaoming
package com.xiaoming;

public class Dog {
    System.out.println("我是第一个包，类名为 Dog");
}
```
```java
// 第二个包文件 包名称为 com.xiaohong
package com.xiaohong;

public class Dog {
    System.out.println("我是第二个包，类名为 Dog");
}
```
```java
// 第三个包文件 包名称为 com.use
// 使用上面两个包
package com.use;

import com.xiaoming.Dog;
// import com.xiaoming.*; * 表示导入com.cioaming 包下的所有类

public class Test {
/**
 * 等价于 com.xiaohong.Dog d1 = new com.xiaohong.Dog();
 * 默认省略
 */
   Dog d1 = new Dog(); 
/**
 * com.xiaohong 就是为了区分不同包的相同类名
 */
   com.xiaohong.Dog d2 = new com.xiaohong.Dog();
}
```
### 包的命名

#### 包的命名规则
**只能包含数字、字母、下划线、小圆点.,但不能用数字开头，不能是关键字或保留字**

#### 包的命名规范
- **一般是小写字母 + 小圆点一般是**
- **com .公司名 .项目名 .业务模块名**

### Java 常用的包
- java.lang  ：lang 包是基本包，默认引入，不需要再引入.
- java.util ：util 包，系统提供的工具包，工具类，使用 Scanner
- java.net ：网络包，网络开发
- java.awt ：是做 java 界面开发，GUI 

### 使用系统包 对数组排序
```java
package com.use;

import com.xiaoming.Dog;

import java.util.Arrays;

public class Test {
   Dog d1 = new Dog();
   com.xiaohong.Dog d2 = new com.xiaohong.Dog();
   public static void main(String[] args){
      int[] arr = {-1, -8, 10, 1, 8};
      Arrays.sort(arr); // 系统包中的方法
      for (int i = 0; i < arr.length; i++){
         System.out.println(arr[i]);
      }
   }
}
```

### 注意事项和使用细节

1. **package** 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package
2. **import**指令 位置放在**package**的下面，在类定义前面,可以有多句且没有顺序要求。

## 访问修饰符

### 介绍
java 提供四种访问控制修饰符号，用于控制方法和属性( 成员变量 ) 的访问权限( 范围 )
:::tip 修饰符号：
1. **公开级别：** 用 **public** 修饰,对外公开
2. **受保护级别：** 用 **protected** 修饰,对子类和同一个包中的类公开
3. **默认级别：** 没有修饰符号,向同一个包的类公开
4. **私有级别：** 用 **private** 修饰,只有类本身可以访问,不对外公开

 **演示**
 ```java
 public class Test {
   int n3 = 30;
   public int n1 = 10;
   protected int n2 = 20;
   private int n4 =40;

   public void setN1() {
      // 同类中 访问四个属性
      System.out.println(this.n1);
      System.out.println(this.n2);
      System.out.println(this.n3);
      System.out.println(this.n4);
   }
}
 ```
:::

## 面向对象的三大特征（封装，继承，多态）

### 封装
#### 介绍
封装 **(encapsulation)** 就是把抽象出的数据 **[属性]** 和对数据的操作 **[方法]** 封装在一起,数据被保护在内部,程序的其它部分只有通过被授权的操作 **[方法]**,才能对数据进行操作。

#### 封装的理解和好处
1. 隐藏实现细节： 方法( 连接数据库 ) <-- 调用( 传入参数...)
2. 可以对数据进行验证，保证安全合理

#### 封装的实现步骤
1. 将属性进行私有化 **private** ( 不能直接修改属性 )
2. 提供一个 set 方法， 用于对属性判断并赋值
3. 提供一个公共的get方法，用于获取属性的值

#### 演示
:::tip  不能随便查看人的年龄,工资等隐私并对设置的年龄进行合理的验证。年龄合理就设置，否则给默认,年龄必须在 1-120,年龄，工资不能直接查看， name 的长度在 2-6 之间
```java
public class Test {
    public static void main(String[] args){
       Person p1 = new Person();
       p1.setName("杨胜军");
       p1.setAge(27);

       /** 调用构造器 */
        Person p = new Person("杨胜军", 10);
        System.out.println(p.info());
    }
}

class Person {
    public String name;
    private int age;

    /** 使用构造器 调用 set 方法 */
    public Person(String name, int age){
        setName(name);
        setAge(age);
    }

    /** get 方法 */
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }

    /** set 方法 */
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    /** 输出信息 */
    public void info(){
        System.out.println("name=" + this.name + "age" + this.age);
    }
}

```
快速生成 get 和 set
![](./images/1.png)
:::

### 继承
**提出代码复用的问题**
- **问题：** 我们编写了两个类，一个是 Pupil 类，一个是 Graduate 问题 : 两个类的属性和方法有很多是相同的，怎么办?

#### 介绍
>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。
#### 基本语法
```java
class 子类 extends 父类 {

}
1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫 超类，基类。
3. 子类又叫派生类。
```
:::tip Pupil 类
```java
public class Pupil {
    public String name;
    public int age;
    private double score;

    public void setScore(double score) {
        this.score = score;
    }
    public void testInfo() {
        System.out.println("小学生" + name + "年龄" + age + "成绩" + score);
    }
}
```
:::
::: tip Greaduate 类
```java
public class Greaduate {
    public String name;
    public int age;
    private double score;
  
    public void setScore(double score) {
        this.score = score;
    }
    public void testInfo() {
        System.out.println("大学生" + name + "年龄" + age + "成绩" + score);
    }
}
```
:::
::: tip Test2 类 中调用 上面两个类
```java 
public class Test2 {
    public static void main(String[] args){
        Pupil pupil = new Pupil();
        pupil.name = "小明";
        pupil.age = 10;
        pupil.setScore(60);
        pupil.testInfo();
        Greaduate greaduate = new Greaduate();
        greaduate.name = "大学生";
        greaduate.age = 22;
        greaduate.setScore(70);
        greaduate.testInfo();
    }
}
```
:::
:::tip
```java

```
:::
- 示意图
![](./images/2.png)

#### 使用细节
 1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问,但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问
    > - **Base** 父类
    > ```java
    >public class Base {
    >    /** 私有属性 */
    >    private int n4 = 400;
    >
    >    /** 父类提供一个 public 方法， 返回私有属性 */
    >    public int getN4(){
    >        return n4;
    >    }
    >    /** 私有方法 */
    >    private void test400(){
    >        System.out.println("test400()...");
    >    }
    >    /** 定义公共方法 将私有方法导出 */
    >    public void callTest400(){
    >        test400();
    >    }
    >}
    > ```
    > - Sum 子类
    > ```java
    > /** 这是子类 继承父类 Base */
    > class Sum extends Base{
    >     public void sayOk(){
    >         /** 访问私父类中的私有属性 */
    >         System.out.println("Sum()..." + getN4());
    >         /** 调用父类中的公共方法从而访问私有方法 */
    >         callTest400();
    >     }
    > }
    > ```
    > - 主方法
    > ```java
    > public class Inheritance {
    >     public static void main(String[] args){
    >         Sum sum = new Sum();
    >         sum.sayOk();
    >     }
    > }
    > ```
 2. 子类必须调用父类的构造器,完成父类的初始化
 3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 **super** 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
>> 子类中没有构造器 不影响
    > - **Base** 父类
    > ```java
    >public class Base {
    >    /** 父类构造器 */
    >      public Base (){
    >           System.out.println("base()...");
    >       }
    >}
    > ```
    > - Sum 子类
    > ```java
    > /** 这是子类 继承父类 Base */
    > class Sum extends Base{
    >     public Sum(){
    >     System.out.println("Sum()...");
    >     }
    >     public Sum(String name){
    >       System.out.println("Sum(有参构造器)...");
    >     }
    >}
    > ```
    > - 主方法
    > ```java
    > public class Inheritance {
    >     public static void main(String[] args){
    >         /** sum 和 sum2 都会调用父类的构造器 */
    >          Sum sum = new Sum();
    >          Sum sum2 = new Sum("杨胜军");
    >     }
    > }
    > ```

>> 父类中没有构造器 则必须使用 **super** 指定构造器
    > - **Base** 父类
    > ```java
    >public class Base {
    >    /** 父类构造器(有参构造器会覆盖默认构造器) */
    >    public Base (String name, int age){
    >       System.out.println("base()...");
    >    }
    >}
    > ```
    > - Sum 子类
    > ```java
    > /** 这是子类 继承父类 Base */
    > class Sum extends Base{
    >     public Sum(){
    >       super("杨胜军", 27);
    >       System.out.println("Sum()...");
    >     }
    >     public Sum(String name){
    >       super("杨胜军222", 29);
    >       System.out.println("Sum(有参构造器)...");
    >     }
    >}
    > ```
    > - 主方法
    > ```java
    > public class Inheritance {
    >     public static void main(String[] args){
    >           System.out.println("这是第一个对象");
    >           Sum sum = new Sum();
    >
    >           System.out.println("这是第二个对象");
    >           Sum sum2 = new Sum("杨胜军");
    >     }
    > }
    > 
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)
    > ```java
    >  super();
    >```
5. super 在使用时，需要放在构造器第一行( super只能在构造器中使用 )
6. **super()** 和 **this()** 都只能放在构造器第一行，因此这两个方法不能共存在一个构
造器
7. java 所有类都是 Object 类的子类, Object 是所有类的基类
8. 父类构造器的调用不限于直接父类!将一直往上追溯直到 Object 类(顶级父类)
9. 子类最多只能继承一个父类(指直接继承)，即java中是 **单继承机制**。
   - **思考:** 如何让A类继承B类和C类? A 继承 B B继承 C
10. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

#### 继承的本质
我们看一个案例来分析当子类继承父类，创建子类对象时，内存中到底发生了什么? 
- 提示: 当子类对象创建好后，建立查找的关系
:::tip 内存的布局 （要按照查找关系来返回信息）
1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属件，就看父举有没有这个属件(如果父类有该属性，并目可以访问，就返问信息。。。）
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到object。.。
- 示意图
![](./images/3..png)
:::

### super 关键字
#### 介绍
> **super** 代表父类的引用，用于访问父类的属性、方法、构造器

### 基本语法
```java
/** 
 * 访问父类的属性，但不能访问父类的private属性 super.属性名; 
 * 访问父类的方法，不能访问父类的 private方法 super.方法名(参数列表);
 * 访问父类的构造器: super(参数列表); 只能放在构造器的第一句，与 this() 只能出现一个!
 */
 public class B extends A {
    public void hi(){
        /** 访问父类中的 n1 与 n2 */
        System.out.println(super.n1 + super.n2)
    }
    public void ok(){
        /** 访问父类中的方法 */
        super.test1();
        super.test2();
    }
 }
```

#### super 带来的便利
1. 调用父类的构造器的好处 (分工明确,父类属性由父类初始化，子类的属性由子类初始化)
2. 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过 **super**。如果没有重名，使用 **super**、**this**、直接访问是一样的效果!
```java
/**
 * 调用 父类A 中的 cal 方法时 顺序如下：
 * 1.先找本类，如果有，则调用
 * 2.如果没有，则找父类(如果有，并可以调用，则调用)
 * 3.如果父类没有，则继续找父类的父类，整个规则，就是一样的 直到 0bject类
 * 提示: 如果找到，但不能访问， 则报错
 *       如果没有找到，则提示方法不存在
 */
 public class B extends A {
    public void hi(){
        /**
         * cal(); 等价于 this.cal();
         * super.cal(); 直接查找父类
         */
        cal(); 
    }
 }
```

3. super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员;如果多个基类(上级类)中都有同名的成员，使用super。访问遵循就近原则。A->B->C

### super 与 this 的比较
![](./images/4.png)

### 方法重写/覆盖（override）

#### 介绍
简单的说:方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样,那么我们就说子类的这个方法覆盖了父类的那个方法

#### 注意事项和细节
:::tip 方法重写也叫方法覆盖，需要满足下面的条件
1. 子类的方法的参数,方法名称,要和父类方法的参数,方法名称完全一样。
2. 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类
比如 父类 返回类型是 object ,子类方法返回类型是 String
3. 子类方法不能缩小父类方法的访问权限
:::

#### 重写与重载比较
![](./images/5.png)

#### 练习
