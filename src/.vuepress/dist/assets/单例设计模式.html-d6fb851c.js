import{_ as s,X as n,Y as a,$ as l}from"./framework-2185e866.js";const p={},e=l(`<h1 id="单例设计模式" tabindex="-1"><a class="header-anchor" href="#单例设计模式" aria-hidden="true">#</a> 单例设计模式</h1><h2 id="什么是设计模式" tabindex="-1"><a class="header-anchor" href="#什么是设计模式" aria-hidden="true">#</a> 什么是设计模式</h2><ol><li>静态方法和属性的经典使用</li><li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式 。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索</li></ol><h2 id="什么是单例设计模式" tabindex="-1"><a class="header-anchor" href="#什么是单例设计模式" aria-hidden="true">#</a> 什么是单例设计模式</h2><ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li><li>单例模式有两种方式: <ul><li>饿汉式</li><li>懒汉式</li></ul></li></ol><h2 id="单例模式应用实例" tabindex="-1"><a class="header-anchor" href="#单例模式应用实例" aria-hidden="true">#</a> 单例模式应用实例</h2><blockquote><p>演示饿汉式和懒汉式单例模式的实现 步骤如下:</p></blockquote><ul><li>1)构造器私有化 防止直接 new</li><li>2)类的内部创建对象</li><li>3)向外暴露一个静态的公共方法。<div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">public</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">class</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">HungryHan</span><span style="color:#E06C75;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> </span><span style="color:#C678DD;">static</span><span style="color:#61AFEF;"> </span><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;">[] </span><span style="color:#E06C75;font-style:italic;">args</span><span style="color:#ABB2BF;">)</span><span style="color:#61AFEF;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//        HungryHanSun hungryHanSun = new HungryHanSun(&quot;小花花&quot;);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//        HungryHanSun hungryHanSun2 = new HungryHanSun(&quot;小花花&quot;);</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">// 通过方法可以获取对象</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">instance</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getInstance</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">instance1</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getInstance</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">System</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">out</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">println</span><span style="color:#ABB2BF;">(instance);</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">System</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">out</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">println</span><span style="color:#ABB2BF;">(instance1);</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">System</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">out</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">println</span><span style="color:#ABB2BF;">(instance1 </span><span style="color:#56B6C2;">==</span><span style="color:#ABB2BF;"> instance);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">class</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#E06C75;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#C678DD;">private</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">String</span><span style="color:#E06C75;"> name</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 如何保证只能创建一个 HungryHanSun 对象</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 步骤【单例模式---饿汉式】：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 1.将构造器私有化</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 2.在类的内部直接创建</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * 3.提供一个公共的 static 方法 返回 hungryHanSun 对象</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">     * */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#7F848E;font-style:italic;">// 为了能够在静态方法中，返回 hungryHanSun 对象，需要将其修饰为 static</span></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#7F848E;font-style:italic;">// 不管是否使用，new HungryHanSun() 都会随着类的加载而创建 显得特别着急，就叫饿汉式</span></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#7F848E;font-style:italic;">// 使用对象：通常是重量级的对象，饿汉式可能造成资源浪费，因为不管是否使用都会加载</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#C678DD;">private</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">static</span><span style="color:#E06C75;"> </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#E06C75;"> hungryHanSun </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">new</span><span style="color:#E06C75;"> </span><span style="color:#61AFEF;">HungryHanSun</span><span style="color:#E06C75;">(</span><span style="color:#98C379;">&quot;小花花&quot;</span><span style="color:#E06C75;">)</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> HungryHanSun</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">String</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">name</span><span style="color:#ABB2BF;">)</span><span style="color:#61AFEF;"> </span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">name</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> name;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#E06C75;">    </span><span style="color:#C678DD;">public</span><span style="color:#61AFEF;"> </span><span style="color:#C678DD;">static</span><span style="color:#61AFEF;"> </span><span style="color:#E5C07B;">HungryHanSun</span><span style="color:#61AFEF;"> getInstance</span><span style="color:#ABB2BF;">(){</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> hungryHanSun;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="饿汉式和懒汉式的区别" tabindex="-1"><a class="header-anchor" href="#饿汉式和懒汉式的区别" aria-hidden="true">#</a> 饿汉式和懒汉式的区别</h2><ol><li>二者最主要的区别在于<strong>创建对象的时机</strong>不同: 饿汉式是在类加载就创建了对象实例而懒汉式是在使用时才创建。</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</li><li>饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。</li><li>在 javaSE 标准类中，java.lang.Runtime就是经典的单例模式</li></ol>`,10),o=[e];function c(t,i){return n(),a("div",null,o)}const y=s(p,[["render",c],["__file","单例设计模式.html.vue"]]);export{y as default};
